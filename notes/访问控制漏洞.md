访问控制（Access Control）漏洞是智能合约安全中最常见且破坏力最大的漏洞类型之一。在区块链环境中，代码一旦部署即不可篡改，如果关键函数（如提款、铸币、更改所有权）缺乏适当的权限检查，攻击者可以轻易接管合约并窃取资产。

---
### 1. 背景 (Background)

在智能合约开发中，访问控制是指限制谁可以调用特定函数或访问特定数据的机制。

* **核心机制：** 通常依赖于检查 `msg.sender`（调用者地址）是否等于合约的所有者（Owner）或具有特定角色的地址。
* **漏洞成因：**
* **修饰符缺失（Missing Modifiers）：** 开发者忘记在敏感函数上添加 `onlyOwner` 或类似的权限修饰符。
* **可见性错误（Incorrect Visibility）：** 将本应为 `internal` 或 `private` 的辅助函数设置为 `public` 或 `external`。
* **逻辑漏洞：** 初始化函数（Initialization）未被正确保护，导致攻击者可以重新初始化合约并成为所有者。
* **tx.origin 误用：** 使用 `tx.origin` 进行鉴权，容易遭受钓鱼攻击（Phishing）。

### 2. 真实案例 (Real-world Case)

#### Parity Multi-Sig Wallet Hack (2017)

这是历史上最著名的访问控制漏洞案例之一。

* **事件概述：** Parity 多重签名钱包合约被黑客攻击，导致超过 150,000 ETH（当时价值约 3000 万美元）被盗。
* **漏洞原理：**
该钱包合约将核心逻辑放在一个名为 `WalletLibrary` 的库合约中。该库包含一个名为 `initWallet` 的函数，用于初始化钱包所有者。然而，该函数是 `public` 的，且没有任何检查防止它在合约初始化后被再次调用。
* **攻击过程：**
1. 攻击者发现 `initWallet` 函数没有访问控制。
2. 攻击者向已部署的钱包合约发送交易，调用 `initWallet`，将自己设置为合约的 Owner。
3. 获得 Owner 权限后，攻击者调用提款函数将资金转走。

> **注：** 随后的第二次 Parity 攻击也是因为访问控制问题（攻击者调用了库合约本身的 `initWallet` 然后触发 `selfdestruct`），导致数亿美元资金被冻结。

---

### 3. 漏洞复现 (Reproduction)

#### 3.1 漏洞代码 (Vulnerable.sol)

下面是简单的一段合约代码：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract VulnerableVault {
    address public owner;
    uint256 public balance;

    constructor() {
        owner = msg.sender;
    }

    receive() external payable {
        balance += msg.value;
    }

    // 🔴 VULNERABILITY: 缺少 onlyOwmer 修饰符
    // 任何人都调用此函数将自己变成 owner
    function changeOwner(address _newOwner) public {
        owner = _newOwner;
    }

    // 只有 owner 可以提款
    function withdraw() public {
        require(msg.sender == owner, "Not owner");
        payable(msg.sender).transfer(address(this).balance);
    }
}

```

地址A部署合约：
![地址A部署合约](../assets/images/访问控制漏洞/Pasted%20image%2020260114163245.png)

#### 3.2 攻击脚本逻辑

攻击者无需复杂的黑客工具，只需在 Etherscan 或使用 Remix、Web3.js 发送一笔交易即可：

1. **观察：** 攻击者发现 `changeOwner` 函数是 `public` 的，且代码中没有 `require(msg.sender == owner)`。
2. **利用：** 攻击者使用自己的地址调用 `changeOwner(attackerAddress)`。
3. **结果：** 合约的 `owner` 变量被更新为攻击者地址。
4. **获利：** 攻击者调用 `withdraw()`。由于 `msg.sender` 现在等于 `owner`，检查通过，合约余额被转走。

**实践过程**：
地址B可直接调用 changeOwner 函数，将合约的所有者替换为自己：
![地址B调用 changeOwner](../assets/images/访问控制漏洞/Pasted%20image%2020260114163414.png)


### 4. 防御与最佳实践 (Defense & Mitigation)

防御访问控制漏洞的核心在于**最小权限原则**和**严格的代码审计**。

#### 4.1 使用标准库 (Use Standard Libraries)

不要手动编写访问控制逻辑，使用经过实战检验的库，如 **OpenZeppelin**。

* **Simple Ownership:** 使用 `Ownable` 合约。
* **Role-Based Access Control (RBAC):** 对于复杂系统，使用 `AccessControl` 合约，分配 `MINTER_ROLE`, `ADMIN_ROLE` 等。

**修复后的代码示例：**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/Ownable.sol";

// 继承 OpenZeppelin 的 Ownable
contract SecureVault is Ownable {
    
    // 构造函数中传递 msg.sender 给 Ownable 初始化
    constructor() Ownable(msg.sender) {}

    receive() external payable {}

    // ✅ DEFENSE: 只有当前 owner 可以转移所有权
    // transferOwnership 是 Ownable 库自带的安全函数
    
    // ✅ DEFENSE: 添加 onlyOwner 修饰符
    function withdraw() public onlyOwner {
        payable(msg.sender).transfer(address(this).balance);
    }
}

```
#### 4.2 检查函数可见性 (Function Visibility)

* 严格区分 `public`, `external`, `internal`, `private`。
* 如果一个函数只应被合约内部调用（如逻辑计算），必须设为 `internal` 或 `private`。

#### 4.3 初始化函数保护 (Protect Initializers)

对于使用代理模式（Proxy Pattern）的可升级合约，`constructor` 不会被执行，必须依靠 `initialize` 函数。

* **防御：** 确保 `initialize` 函数只能被调用一次。使用 OpenZeppelin 的 `Initializable` 合约和 `initializer` 修饰符。
#### 4.4 避免使用 tx.origin

* 永远不要使用 `tx.origin` 进行鉴权。如果合约 A 鉴权依赖 `tx.origin == owner`，攻击者可以诱导 Owner 调用攻击合约 B，B 再调用 A。此时 `tx.origin` 是 Owner，但 `msg.sender` 是攻击合约 B。
* **防御：** 始终使用 `msg.sender`。


# 总结

访问控制漏洞常见的爆破点：
可以将这些漏洞点分为三个层面：**代码定义层（可见性）**、**逻辑实现层（修饰符与状态）和架构层（代理与鉴权）**。
### 1. 代码定义层：函数可见性错误 (Visibility Issues)
这是最基础但也最容易被忽视的漏洞点。
* **漏洞点：** 应该设为 `internal` 或 `private` 的辅助函数被错误地设为了 `public` 或 `external`
* **高危场景：**
	* **`_mint` / `_burn` 函数：** 很多代币合约会将实际的铸币逻辑写在一个带下划线前缀的函数中（如 `_mint`）。如果忘记限制其可见性，任何人都能调用它给自己铸币。
* **配置修改函数：** 修改费率、修改预言机地址的函数。

* **代码特征：**
```solidity
// 错误：public 可见性，任何人都能调用
function _updateScore(address user, uint256 newScore) public {
    scores[user] = newScore;
}

// 正确：internal，只能被合约内部的其他安全函数调用
function _updateScore(address user, uint256 newScore) internal {
    scores[user] = newScore;
}

```

### 2. 逻辑实现层：遗漏修饰符 (Missing Modifiers)

这是最常见的疏忽。开发者写了函数，定义了它是 `public` 的，但忘记挂载 `onlyOwner` 或其他 RBAC（基于角色的访问控制）修饰符。

* **漏洞点：** 敏感操作函数没有任何 `require` 检查或 `modifier`。
* **高危场景：**
* **`withdraw()` / `drain()`：** 提取合约资产。
* **`setOwner()` / `transferOwnership()`：** 更改合约管理员。
* **`pause()` / `unpause()`：** 紧急暂停开关。

* **攻击技巧：** 在代码中搜索所有 `public` 和 `external` 函数，逐一确认：*“这个函数是否可利用？”*

### 3. 架构层：代理合约的初始化 (Unprotected Initialize)

在使用代理模式（Proxy Pattern，如 ERC1967/Transparent/UUPS）时，合约无法使用 `constructor`，必须使用 `initialize` 函数。

* **漏洞点：** `initialize` 函数也是 `public` 的，且没有“只能调用一次”的保护，或者合约部署后管理员忘记第一时间调用它。
* **攻击方式：** 攻击者抢在管理员之前调用 `initialize`，或者在管理员遗漏保护机制时重复调用它（Re-initialization），将自己设为 Owner。
* **代码特征：**
```solidity
// 错误：没有 initializer 修饰符，可以被反复调用覆盖 owner
function initialize(address _owner) public {
    owner = _owner;
}

// 正确：使用 OpenZeppelin 的 Initializable
function initialize(address _owner) public initializer {
    owner = _owner;
}

```


### 4. 鉴权源错误：tx.origin 钓鱼 (Phishing with tx.origin)

虽然现在较少见，但仍存在于老旧代码或新手代码中。

* **漏洞点：** 使用 `tx.origin` 来判断调用者身份，而不是 `msg.sender`。
* **原理：** `tx.origin` 永远是交易发起的外部账户（EOA），而 `msg.sender` 是直接调用该函数的地址（可能是合约）。
* **攻击场景：** 攻击者诱骗管理员访问一个恶意钓鱼合约，恶意合约再调用受害目标合约。此时 `tx.origin` 是管理员，目标合约会误以为是管理员在操作，从而放行。

### 5. 签名验证绕过 (Signature Verification Bypass)

在涉及链下签名、链上执行（如 Permit, Meta-transactions）的场景中，访问控制依赖于密码学签名验证。

* **漏洞点：**
* **未检查 `ecrecover` 的返回值：** `ecrecover` 在出错时可能返回 `address(0)`。如果合约内没有检查返回值是否有效，且某个特权角色（如 owner）未被初始化（也是 `address(0)`），攻击者可以通过构造错误签名来冒充 Owner。
* **签名重放 (Replay Attack)：** 没有包含 `nonce` 或 `chainId`。攻击者可以截获管理员以前的有效签名，再次发送给合约执行（例如再次提取资金）。

### 6. 容易被忽视的“后门”

* **Debug/Test 代码遗留：** 开发者在测试阶段留下的 `function kill() public` 或 `function setupForTest() public` 未在主网部署前删除。
* **未使用的 public 变量：** 如果某个关键变量（如 `minDeposit`）是 `public` 的，虽然它自动生成了 getter 函数，但在某些旧版本编译器或特定逻辑下，如果没有显式的 setter 保护，可能会被通过底层的 `delegatecall` 意外修改（较为复杂，属于存储布局冲突）。

# 附录

## Parity 多重签名钱包攻击梳理

Parity 多重签名钱包（Multi-Sig Wallet）[合约地址 | Etherscan](https://etherscan.io/address/0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4#code)遭受过两次重大攻击，分别发生在 2017 年 7 月（被盗）和 2017 年 11 月（冻结）。

这两次攻击都源于对**库合约（Library Contract）架构以及 `delegatecall`** 机制的理解不足。

### 核心概念前置：Proxy 与 Library

Parity 钱包为了节省 Gas 费，采用了一种**“存钱罐 + 说明书”**的架构：
* **存钱罐 (Wallet Contract):** 这是用户的钱包，里面存放着 ETH。它很轻量，几乎没有代码，只有“钱”和“状态（谁是主人）”。
* **说明书 (Library Contract):** 这是一个公共的合约，存放了所有的逻辑代码（如何提款、如何添加主人）。
* **机制 (Delegatecall):** 当用户调用钱包时，钱包通过 `delegatecall` 去借用 Library 的代码，**在钱包自己的上下文中执行**。

### 第一阶段：Parity Hack 1 (Theft) — 2017年7月

**漏洞类型：** 函数可见性错误 + 初始化逻辑未保护
**损失：** ~15 万 ETH（约 3000 万美元）

#### 1. 漏洞代码分析

在共享的库合约 `WalletLibrary` 中，有一个初始化函数 `initWallet`。

```solidity
// WalletLibrary.sol (简化版)
contract WalletLibrary {
    address[] public m_owners;

    // 🔴 漏洞点：
    // 1. 这是一个 public 函数，任何人都可以调用。
    // 2. 没有检查合约是否已经初始化过了 (missing `onlyUninitialized`)。
    function initWallet(address[] _owners, uint _required, uint _daylimit) public {
        m_owners = _owners;
        // ... 其他初始化逻辑
    }
    
    // 只有 owner 列表里的人才能调用
    function execute(address _to, uint _value, bytes _data) external {
        // 检查 msg.sender 是否在 m_owners 里
        // 执行转账
    }
}

```

#### 2. 正常流程

1. 用户部署一个新的钱包合约。
2. 在构造函数中，钱包自动调用 `initWallet`，将用户设为 `m_owners`。
3. 此时，钱包的 storage 中，`m_owners = [UserAddress]`。

#### 3. 攻击利用过程

黑客发现 `initWallet` 函数即使在合约部署后，依然是对外暴露（`public`）且可调用的。
1. **扫描：** 黑客扫描区块链，找到所有使用该 Library 的钱包合约地址。

2. **夺权 (Takeover)：**
* 黑客向受害者的**钱包合约**发起一笔交易，调用 `initWallet([HackerAddress], ...)`。
* 钱包合约执行 `delegatecall` 到 Library 的 `initWallet` 代码。
* **关键点：** 代码在钱包的存储空间运行。代码执行 `m_owners = _owners`。
* **结果：** 受害者钱包的 `m_owners` 被覆盖为黑客的地址。

3. **提款 (Drain)：**
* 黑客调用钱包的 `execute` 函数（相当于提款）。
* 合约检查 `msg.sender`（黑客）是否在 `m_owners` 里？**是**。
* 转账成功，资金被盗。

### 第二阶段：Parity Hack 2 (Freeze) — 2017年11月

**漏洞类型：** 库合约未初始化 + 自毁函数 (Self-destruct)
**损失：** ~51 万 ETH 被永久冻结（包括 Polkadot 的 ICO 资金）。

在第一次攻击后，Parity 修复了代码，添加了修饰符确保 `initWallet` 只能调用一次。**但是，他们犯了一个更隐晦的错误。**

#### 1. 背景

所有的用户钱包都指向同一个**公共的** Library 合约地址。如果这个 Library 合约出了问题，所有依赖它的钱包都会瘫痪。

#### 2. 漏洞复现逻辑

这次的主角是一个名为 `devops199` 的用户（很多分析认为他是误操作的新手，而非恶意黑客）。

* **事实 A：** Library 本身也是一个合约，它也有自己的存储空间。
* **事实 B：** 开发者虽然修补了钱包的初始化逻辑，但**忘记初始化 Library 合约本身**。这意味着 Library 合约在它自己的存储空间里，`m_owners` 是空的（或者说，处于未初始化状态）。
* **事实 C：** Library 代码里包含一个清理函数：
```solidity
function kill(address _to) onlymanyowners(sha3(msg.data)) external {
    // 自毁函数，销毁合约代码，清理 storage
    suicide(_to); // suicide 是 selfdestruct 的旧称
}

```

#### 3. 利用过程 (The "Oops" Moment)

1. **夺取 Library 所有权：**
`devops199` 直接向 **Library 合约地址** 发送了一笔交易，调用 `initWallet([devops199])`。
* 因为 Library 合约本身从未被初始化过，这次调用成功了。
* 现在，`devops199` 变成了 **Library 合约** 的 Owner。


2. **触发自毁：**
`devops199` 调用了 Library 的 `kill()` 函数。
* 因为他是 Owner，检查通过。
* **结果：** Library 合约执行 `selfdestruct`。


3. **灾难发生：**
* Library 合约的代码被从以太坊上**彻底抹除**。该地址变成了一个空地址。
* 全世界数千个 Parity 多签钱包依然指向这个地址。
* 当这些钱包试图调用任何功能（提款、转账）时，它们会 `delegatecall` 到一个空地址。
* **Delegatecall 到空地址的特性：** 它会返回 `True`（执行成功），但什么都不做。无法转账，无法修改状态。
* **结局：** 所有的 ETH 都被永久锁死在这些钱包里，成了“数字僵尸”。
