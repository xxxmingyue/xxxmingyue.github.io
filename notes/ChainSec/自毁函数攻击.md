# 以太坊智能合约安全：Selfdestruct (自毁) 强制转账漏洞


## 1. 背景 (Background)

在以太坊及 EVM 兼容链的 Solidity 语言中，存在一个名为 `selfdestruct`（在早期版本中称为 `suicide`）的操作码。

* **正常功能：** 设计初衷是允许开发者从区块链中移除废弃或错误的合约代码，以节省区块链的状态空间。
* **强制转账特性（攻击核心）：** 当一个合约执行 `selfdestruct(targetAddress)` 时，它会销毁自身，**并在 EVM 底层将该合约地址上剩余的所有 Ether 强制发送给 `targetAddress**`。

### 为什么这是一个漏洞？

通常情况下，智能合约通过 `fallback` / `receive` 函数，或者标记为 `payable` 的函数来接收 ETH。这使得合约拥有“拒绝”不合法转账的能力（例如，当转账金额不符合要求时触发 `revert`）。

> **核心危险点：** `selfdestruct` 触发的转账**不经过目标合约的任何代码**。它在 EVM 层面直接修改余额。这意味着没有任何代码可以阻止资金流入。如果目标合约的业务逻辑依赖于 `address(this).balance`（当前合约的总余额），攻击者就可以通过强制塞入少量 ETH 来破坏该逻辑。


## 2. 漏洞示例：幸运七号 (EtherGame)

假设有一个名为“幸运七号”的游戏合约。

* **游戏规则：** 玩家每次向合约存入 1 ETH。
* **胜利条件：** 第 7 个存入的玩家获胜。此时合约内余额应正好为 7 ETH，获胜者取走全部奖金。

**关键逻辑代码：**

```solidity
require(address(this).balance <= 7 ether, "Game Over");
if (address(this).balance == 7 ether) {
    winner = msg.sender;
}

```

### 💣 攻击场景 (DoS 攻击)

1. **正常进行：** 正常玩家已经累计存入了 6 ETH。
2. **恶意准备：** 攻击者创建一个恶意合约，并向其中存入极少量资金（例如 `0.000001 ETH`）。
3. **发动攻击：** 攻击者调用恶意合约的 `selfdestruct`，将目标指向“幸运七号”合约。
4. **强制改变状态：** “幸运七号”合约的余额瞬间被强行修改为 `6.000001 ETH`。

**灾难性后果：**
当下一个诚实玩家尝试存入 1 ETH 时，`address(this).balance` 将变成 `7.000001 ETH`。胜利条件 `balance == 7 ether` **永远无法满足**。游戏永久锁死，所有资金被冻结。


## 3. 代码演示 (Demo)

### A. 受害者合约 (Vulnerable Contract)

这是一个严重依赖 `address(this).balance` 的脆弱合约。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract EtherGame {
    uint public targetAmount = 7 ether;
    address public winner;

    function deposit() public payable {
        require(msg.value == 1 ether, "You can only send 1 Ether");

        // --- ⚠️ 漏洞点：直接使用 balance 判断游戏状态 ---
        uint balance = address(this).balance;
        
        require(balance <= targetAmount, "Game is over");

        if (balance == targetAmount) {
            winner = msg.sender;
        }
    }

    function claimReward() public {
        require(msg.sender == winner, "Not winner");
        (bool sent, ) = msg.sender.call{value: address(this).balance}("");
        require(sent, "Failed to send Ether");
    }
}

```

### B. 攻击者合约 (Attacker Contract)

用于实施自毁攻击，实施强制注资。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract Attack {
    address payable public targetContract;

    constructor(address payable _targetContract) payable {
        targetContract = _targetContract;
    }

    // 攻击函数
    function attack() public {
        // 合约销毁后，余额会被 EVM 强制转给 targetContract
        selfdestruct(targetContract);
    }
}

```

## 4. 防御方案 (Defense)

> **防御核心原则：** 永远不要依赖 `address(this).balance` 作为核心业务逻辑的判断依据，因为这个值是可以被外界（通过挖矿奖励或 `selfdestruct`）强制操纵的。

### 解决方案：使用自定义状态变量

定义一个独立的变量（如 `balance`）来追踪合法的存款金额，只相信合约内部函数正常执行时的资金流入。

**修复后的代码：**

```solidity
contract EtherGameFixed {
    uint public targetAmount = 7 ether;
    address public winner;
    
    // ✅ 使用内部状态变量来记录合法的存款
    uint public balance; 

    function deposit() public payable {
        require(msg.value == 1 ether, "You can only send 1 Ether");

        // ✅ 仅在通过正常途径存款时更新内部变量
        balance += msg.value;

        require(balance <= targetAmount, "Game is over");

        if (balance == targetAmount) {
            winner = msg.sender;
        }
    }
}

```

**为什么有效？**
即使攻击者通过 `selfdestruct` 强制塞入 100 ETH，虽然 `address(this).balance` 增加了，但自定义的 `balance` 变量**不会增加**。游戏逻辑依赖于后者，因此安全无虞。

---

### 关于 EIP-6780 (坎昆升级) 的重要提示

以太坊在 Dencun (坎昆) 升级中引入了 [EIP-6780](https://eips.ethereum.org/EIPS/eip-6780)，对 `selfdestruct` 进行了修改：

* **功能削弱：** 现在 `selfdestruct` 只有在合约创建的**同一笔交易**中被调用时，才会真正销毁合约代码和存储。
* **强制转账依然保留：** 无论是否删除了代码，**强制将合约余额发送给目标地址的功能依然存在**。

**结论：** 尽管 `selfdestruct` 不再像以前那样“毁尸灭迹”，但上述的**强制转账攻击向量依然有效**，开发者在编写合约时仍需严格防范。